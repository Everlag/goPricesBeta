package deckDB

import (
	"fmt"

	"github.com/jackc/pgx"

	"encoding/json"
	"io/ioutil"
	"path/filepath"
	"os"

	"crypto/tls"

	"./nameNorm"
)


// Errors we may return when executing statements
var ConnError error = fmt.Errorf("db connection failed")
var ScanError error = fmt.Errorf("failed to scan row")


// A list of all statements we support, these are prepared on a per
// connection basis.
const cardInsert string = "addCard"
const deckInsert string = "addDeck"
const eventInsert string = "addEvent"

const archetypeContents string = "contentsArchetype"
const archetypeLatest string = "latestArchetype"

const deckContents string = "contentsDeck"

const eventExists string = "existsEvent"


var statements = []string{
	cardInsert, deckInsert, eventInsert,
	archetypeContents, archetypeLatest,
	deckContents,
	eventExists,
}

const statementLoc string = "sql"
const statementExtension string = ".sql"

const configName string = "postgres.config.json"
const certName string = "server.crt"

func fetchRawStatement(name string) (string, error) {

	loc := filepath.Join(statementLoc, name)
	loc = loc + statementExtension

	// Wonderful function generated by go-bindata that allows us the
	// ability to embed our sql in the package!
	result, err := Asset(loc)
	if err != nil {
		return "", fmt.Errorf("failed to acquire statement, ", err)
	}

	return string(result), nil

}

// Sets everything a connection could need up.
//
// Lets us refer to our stored sql very easily.
func afterConnect(conn *pgx.Conn) (err error) {

	// Prepare all the predefined statements
	var text string
	for _, statementName := range statements {

		// Each connection loads the statement off of disk. Not optimal
		text, err = fetchRawStatement(statementName)
		if err != nil {
			return err
		}

		_, err = conn.Prepare(statementName, text)
		if err != nil {
			err = fmt.Errorf("Failed to prepare statement ", statementName, err)
			return err
		}

	}

	return

}

// Connects to the remote postgres server defined in postgres.config.json
//
// Uses the certificate found in certs/server.crt to establish trust
func Connect() (*pgx.ConnPool, error) {

	// Determine config location
	configRoot:= os.Getenv("POSTGRES_CONFIG")
	configLoc:= filepath.Join(configRoot, configName)

	// Create our pool.
	//
	// In most cases InsecureSkipVerify would be very poor but since
	// we are handling our cert chain ourselves with self signed certs
	// this is not an issue.
	connPoolConfig, err := readConfig(configLoc)
	if err != nil {
		return nil, err
	}

	pool, err := pgx.NewConnPool(*connPoolConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection pool,", err)
	}

	// Initialize nameNorm if not already done
	//
	// We need it to normalize the deck names we store
	// so matching can be more liberal
	if !nameNorm.Ready() {
		nameNorm.Begin()
	}

	return pool, nil

}

type Config struct {
	Host, User, Password, Database string
}

func readConfig(loc string) (*pgx.ConnPoolConfig, error) {
	raw, err := ioutil.ReadFile(loc)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire config", err)
	}

	var c Config
	err = json.Unmarshal(raw, &c)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal config", err)
	}

	// Figure out where trust root is
	certRoot:= os.Getenv("POSTGRES_CERT")
	certLoc:= filepath.Join(certRoot, certName)

	// Acquire our trust chain so we can connect
	trustRoot, err := grabCert(certLoc)
	if err != nil {
		return nil, err
	}

	connPoolConfig := pgx.ConnPoolConfig{
		ConnConfig: pgx.ConnConfig{
			Host:     c.Host,
			User:     c.User,
			Password: c.Password,
			Database: c.Database,
			TLSConfig: &tls.Config{
				RootCAs:            trustRoot,
				InsecureSkipVerify: true,
			},
		},
		MaxConnections: 50,
		AfterConnect:   afterConnect,
	}

	return &connPoolConfig, nil

}
